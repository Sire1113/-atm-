#include "FileHandler.h"
//将账户写入文件
bool FileHandler::writeAccountToFile(const Account& account, int key) {
    ofstream fileOut("accounts.dat", ios::app); // 使用追加模式
    if (!fileOut) {
        cerr << "无法打开文件写入。\n";
        return false;
    }
    fileOut << EncryptionUtilities::encryptDecrypt(account.getID(), key) << " "
        << account.getName() << " "
        << EncryptionUtilities::encryptDecrypt(account.getPassword(), key) << " "
        << account.getBalance() << endl;
    fileOut.close();
    return true;
}

// 从文件中读取账户信息并验证密码
bool FileHandler::verifyAccountPassword(const  string& id, const  string& password, int key) {
    ifstream fileIn("accounts.dat");
    if (!fileIn) {
        cerr << "无法打开文件读取。\n";
        return false;
    }

    string line;
    while (getline(fileIn, line)) {
        istringstream iss(line);
        string fileID, filePassword, fileName;
        double fileBalance;
        if (iss >> fileID >> fileName >> filePassword >> fileBalance) {
            if (fileID == EncryptionUtilities::encryptDecrypt(id, key) &&
                EncryptionUtilities::encryptDecrypt(filePassword, -key) == password) {
                fileIn.close();
                return true;
            }
        }
    }
    fileIn.close();
    return false;
}
// 更新账户密码
bool FileHandler::updatePassword(const  string& id, const  string& oldPassword, const  string& newPassword, int key) {
    // 使用一个临时文件存储新的账户信息
    string tempFilename = "accounts_temp.dat";
    ifstream file("accounts.dat");
    ofstream tempFile(tempFilename);

    bool isUpdated = false;
    if (file.is_open() && tempFile.is_open()) {
        string fileID, fileName, filePassword;
        double fileBalance;

        while (file >> fileID >> fileName >> filePassword >> fileBalance) {
            if (fileID == EncryptionUtilities::encryptDecrypt(id, key)) {
                // 解密并比较密码
                string decryptedPassword = EncryptionUtilities::encryptDecrypt(filePassword, -key);
                if (decryptedPassword == oldPassword) {
                    // 若旧密码正确，使用新密码并加密后写入临时文件
                    isUpdated = true;
                    filePassword = EncryptionUtilities::encryptDecrypt(newPassword, key);
                }
                else {
                    // 旧密码不正确，不更新信息，返回失败
                    cerr << "旧密码不正确，无法更新。\n";
                    return false;
                }
            }
            // 将账户信息写入临时文件中
            tempFile << fileID << " " << fileName << " " << filePassword << " " << fileBalance << "\n";
        }

        file.close();
        tempFile.close();

        if (isUpdated) {
            // 使用新的账户文件替换旧的文件
            remove("accounts.dat");
            rename(tempFilename.c_str(), "accounts.dat");
        }
        else {
            // 若没有更新任何内容，删除临时文件
            remove(tempFilename.c_str());
            cerr << "没有找到对应的账户进行更新。\n";
        }

    }
    else {
        cerr << "无法打开文件进行更新。\n";
        return false;
    }
    return isUpdated;
}
// 写入交易记录至文件
bool FileHandler::writeStatementToFile(const Statement& statement, const int& key) {
    ofstream fileOut("statements.dat", ios::app); // 使用追加模式打开交易流水记录文件
    if (!fileOut) {
        cerr << "无法打开文件写入交易记录。\n";
        return false;
    }

    // 存入交易信息，格式化为流水编号 账户卡号 交易时间 交易类型 交易金额 对方账户
    fileOut << statement.getID() << "\t"
        << EncryptionUtilities::encryptDecrypt(statement.getAccountID(), generateKey(statement.getAccountID())) << " "
        << statement.getTime() << " "
        << statement.getType() << " "
        << statement.getAmount() << " "
        << EncryptionUtilities::encryptDecrypt(statement.getToAccountID(),generateKey(statement.getToAccountID())) << endl;
    fileOut.close();
    return true;
}

// 从文件中读取账户的所有交易流水记录
void FileHandler::readStatements(const  string& accountID,const int &key) {
    ifstream fileIn("statements.dat");
    if (!fileIn) {
        cerr << "无法打开文件读取交易记录。\n";
        return;
    }

    string line;
    cout << "流水编号 账户卡号 交易时间 交易类型 交易金额 对方账户\n";
    while (getline(fileIn, line)) {

        istringstream iss(line);
        string id, accID, time, toAccID;
        int type;
        double amount;
        if (iss >> id >> accID >> time >> type >> amount >> toAccID) {
            // cout << 1 <<  endl;
            if (EncryptionUtilities::encryptDecrypt(accID,-key) == accountID || EncryptionUtilities::encryptDecrypt(toAccID,-key)==accountID) {
                cout << id << " " << EncryptionUtilities::encryptDecrypt(accID, -key) << " " << time << " " << type << " " << amount << " " << EncryptionUtilities::encryptDecrypt(toAccID, -key) << endl;
            }
            else {
                // cout << accID <<  endl;
            }
        }
    }
    fileIn.close();
}

// 更新账户余额
bool FileHandler::updateAccountBalance(const  string& id, double newBalance, int key) {
    ifstream fileIn("accounts.dat");
    ofstream fileOut("accounts_temp.dat");
    bool isUpdated = false;

    if (fileIn && fileOut) {
        string fileID, fileName, filePassword;
        double fileBalance;
        while (fileIn >> fileID >> fileName >> filePassword >> fileBalance) {
            if (fileID == EncryptionUtilities::encryptDecrypt(id, key)) {
                fileBalance = newBalance;  // 更新余额
                isUpdated = true;
            }
            fileOut << fileID
                << " " << fileName << " "
                << filePassword << " "
                << fileBalance << endl;
        }
        fileIn.close();
        fileOut.close();

        // 删除旧账户文件并将临时文件重命名为新账户文件
        remove("accounts.dat");
        rename("accounts_temp.dat", "accounts.dat");
    }
    else {
        cerr << "无法打开文件进行更新。\n";
        if (fileIn) fileIn.close();
        if (fileOut) {
            fileOut.close();
            remove("accounts_temp.dat");  // 删除临时文件
        }
        return false;
    }
    return isUpdated;
}

// 获取账户余额
double FileHandler::getAccountBalance(const  string& id, int key) {
    ifstream fileIn("accounts.dat");
    if (!fileIn) {
        cerr << "无法打开文件来获取余额。\n";
        return -1; // 使用错误值表示无法获取余额
    }

    string fileID, fileName, filePassword;
    double fileBalance;
    while (fileIn >> fileID >> fileName >> filePassword >> fileBalance) {
        if (fileID == EncryptionUtilities::encryptDecrypt(id, key)) {
            fileIn.close();
            return fileBalance; // 返回解密后的账户余额
        }
    }
    fileIn.close();
    cerr << "没找到对应的账户余额。\n";
    return -1; // 使用错误值表示账户不存在
}

// 按ID检索账户信息
Account* FileHandler::retrieveAccountById(const  string& id, int key) {
    ifstream fileIn("accounts.dat");
    if (!fileIn) {
        cerr << "无法打开文件读取账户信息。\n";
        return nullptr; // 返回 nullptr 表示没找到账户
    }

    string fileID, fileName, filePassword;
    double fileBalance;
    while (fileIn >> fileID >> fileName >> filePassword >> fileBalance) {
        // 解密并检查ID是否匹配
        if (EncryptionUtilities::encryptDecrypt(fileID, -key) == id) {
            fileIn.close();
            // 返回动态分配的对应的账户对象
            return new Account(id, fileName, filePassword, fileBalance);
        }
    }

    fileIn.close();
    cerr << "未找到匹配的账户ID。\n";
    return nullptr; // 未找到账户，返回 nullptr
}


